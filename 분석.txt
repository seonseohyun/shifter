### 코드 전체 개요

이 코드는 Python으로 작성된 근무표 생성 서버입니다. 주요 목적은 사용자로부터 직원 데이터, 시프트 유형, 직군 정보 등을 입력받아 OR-Tools 라이브러리의 제약 조건 만족 문제(Constraint Programming, CP) 솔버를 활용하여 자동으로 근무 스케줄을 생성하는 것입니다. 서버는 소켓 통신을 통해 클라이언트의 JSON 요청을 처리하며, 다양한 직군(예: 간호, 소방)에 특화된 제약 조건을 적용합니다. 커스텀 규칙을 지원하여 유연성을 제공하며, 입력 검증과 오류 처리를 통해 안정성을 강화합니다. 코드의 구조는 모듈 임포트, 상수 정의, 유틸리티 함수, 주요 스케줄 생성 함수, 요청 처리 함수, 서버 실행 함수로 구성되어 있습니다. 실행 환경은 Python 3.12.3 이상을 가정하며, OR-Tools와 기본 라이브러리를 사용합니다.

### 모듈 및 임포트 분석

코드의 시작 부분에서 다음과 같은 모듈을 임포트합니다:

- `socket`: 소켓 기반 네트워크 통신을 위한 모듈로, 서버-클라이언트 연결을 처리합니다.
- `json`: JSON 데이터 파싱과 직렬화를 담당합니다. 클라이언트 요청과 응답을 JSON 형식으로 교환합니다.
- `datetime`과 `timedelta`: 날짜 및 시간 계산을 위해 사용되며, 대상 월의 시작일과 일수를 동적으로 계산합니다.
- `calendar`: 해당 월의 일수를 구하는 데 활용됩니다.
- `ortools.sat.python.cp_model`: OR-Tools의 CP 솔버를 위한 모듈로, 제약 조건 모델링과 해결을 담당합니다.
- `os`: 파일 시스템 작업(예: 디렉토리 생성, 파일 저장)을 수행합니다.

이 임포트들은 서버 운영, 데이터 처리, 날짜 관리, 최적화 모델링을 지원하며, 외부 패키지 설치 없이 기본 환경에서 동작하도록 설계되었습니다.

### 상수 및 데이터 구조

- `HOST`와 `PORT`: 서버의 호스트 주소('127.0.0.1')와 포트(6002)를 정의합니다. 로컬 호스트에서 동작하도록 설정되어 있습니다.
- `POSITION_RULES`: 딕셔너리 형태의 직군별 제약 조건 규칙입니다. 각 직군(간호, 소방, default)에 대해 최소 휴무일, 야간 근무 제한, 주/월 근무시간 상한, 시프트 유형, 시프트별 시간 등을 저장합니다.
  - "간호": 신규 간호사 야간 금지, 야간 후 휴무 의무, 최소 3일 휴무, 주 60시간/월 190시간 상한.
  - "소방": 3일 주기(D24-O-O), 월 8-12회 D24 근무, 주 72시간/월 190시간 상한.
  - "default": 기본 규칙으로, 야간 후 휴무, 최소 2일 휴무, 주 60시간/월 180시간 상한.
  이 구조는 직군별로 규칙을 모듈화하여 확장성을 제공합니다.

### 함수별 상세 분석

#### 1. `parse_target_month(target_month)`

이 함수는 대상 월을 파싱하여 시작 날짜와 해당 월의 일수를 반환합니다.

- 입력: `target_month` (문자열 형식 'YYYY-MM', 옵션).
- 처리 과정:
  - 입력이 없으면 현재 연도와 월을 사용합니다.
  - 해당 월의 첫째 날(`datetime(year, month, 1)`)과 일수(`calendar.monthrange`)를 계산합니다.
  - 오류 발생 시 기본값(2025년 8월, 31일)을 반환합니다.
- 출력: 시작 날짜 객체와 일수 정수.
- 목적: 동적 날짜 계산을 통해 월별 스케줄 생성을 지원합니다. 로그를 통해 정보와 오류를 출력합니다.

#### 2. `apply_position_constraints(model, schedule, person, days, shifts, shift_hours, num_weeks, rules, position)`

직군별 제약 조건을 CP 모델에 적용하는 핵심 함수입니다.

- 입력: CP 모델, 스케줄 변수 딕셔너리, 직원 정보, 날짜 범위, 시프트 목록, 시프트 시간, 주 수, 규칙 딕셔너리, 직군.
- 처리 과정:
  - 직원별로 로그를 출력하며 제약을 적용합니다.
  - "간호" 직군: 신규 간호사 야간 금지, 야간 후 휴무/근무 금지, 최소 휴무일.
  - "소방" 직군: D24 후 오프 의무, 월 D24 횟수 제한(8-12회).
  - 공통: 주/월 근무시간 상한 및 하한(목표 시간 ± 여유분), 로그 출력.
- 출력: 없음 (모델에 직접 제약 추가).
- 목적: 직군별 법적/운영적 규칙을 모델에 반영하여 현실적인 스케줄을 보장합니다.

#### 3. `validate_request_parameters(staff_data, shift_type, position, custom_rules)`

요청 매개변수의 유효성을 검증하는 함수입니다.

- 입력: 직원 데이터, 시프트 유형, 직군, 커스텀 규칙.
- 처리 과정:
  - 직원 데이터: 존재 여부, 필수 필드(name, staff_id 등) 확인, 근무시간 범위(100-250시간) 검증.
  - 커스텀 규칙: shifts와 shift_hours 필드 존재, 시프트 개수(2-6개), 휴무 시프트 포함, 시간 배정 적절성(휴무=0, 근무=4-24시간) 확인.
  - 추가 검증: 일일/월 최대 시간 타당성, 직원 수와 교대 시스템 호환성(예: 4교대 시 20명 이상 권장).
- 출력: 오류 목록과 경고 목록.
- 목적: 입력 오류를 사전에 차단하여 솔버 실패를 방지합니다. 상세 메시지를 통해 디버깅을 용이하게 합니다.

#### 4. `create_individual_shift_schedule(staff_data, shift_type, position="default", target_month=None, custom_rules=None)`

근무 스케줄을 생성하는 메인 함수입니다.

- 입력: 직원 데이터, 시프트 유형, 직군, 대상 월, 커스텀 규칙.
- 처리 과정:
  - 입력 검증: 오류 시 실패 응답 반환.
  - 모델 초기화: CP 모델 생성, 기본/커스텀 규칙 적용.
  - 변수 정의: 각 직원-날짜-시프트에 불린 변수 생성.
  - 기본 제약: 매일 한 시프트 배정, 각 시프트 최소 1명 배정.
  - 직군 제약 적용: `apply_position_constraints` 호출.
  - 야간 균등 분배: 야간 시프트가 있으면 최소-최대 차이 최소화 (목적 함수).
  - 솔버 실행: 시간 제한(20초), 상태 확인.
  - 실패 시: 상세 이유 반환 (예: 제약 불만족, 시간 초과).
  - 성공 시: 날짜별 스케줄 생성, 월 근무시간 통계 계산, JSON 파일 저장.
- 출력: 스케줄 딕셔너리 또는 실패 응답.
- 목적: CP 솔버를 통해 최적화된 스케줄을 생성하며, 야간 균등성을 우선합니다. 성능 최적화(시간 단축, 로그 비활성화)로 실용성을 높입니다.

#### 5. `handle_request(request_json)`

클라이언트 요청을 처리하는 함수입니다.

- 입력: JSON 문자열.
- 처리 과정:
  - JSON 파싱, 데이터 추출.
  - 입력 검증: staff_data 필수.
  - 스케줄 생성 함수 호출.
  - 실패 시 오류 응답, 성공 시 스케줄 JSON 반환.
  - 예외 처리: JSON 오류, 서버 내부 오류.
- 출력: JSON 문자열.
- 목적: 서버의 엔트리 포인트로, 안전한 요청 처리를 보장합니다.

#### 6. `run_server()`

서버를 실행하는 함수입니다.

- 처리 과정:
  - 소켓 생성, 바인딩, 리스닝.
  - 무한 루프: 클라이언트 연결 수락, 데이터 수신, `handle_request` 호출, 응답 전송.
- 출력: 없음 (서버 운영).
- 목적: 지속적인 서비스 제공, 로그를 통해 연결과 데이터를 모니터링합니다.

### 주요 로직 및 특징

- **CP 모델링**: 불린 변수로 스케줄을 표현하며, ExactlyOne(한 시프트 배정), Add(sum >=1, 최소 인원), Implication(야간 후 휴무) 등의 제약을 사용합니다. 목적 함수는 야간 균등성 최소화에 초점을 맞춥니다.
- **오류 처리**: 다단계 검증과 상세 메시지로 사용자 피드백을 강화합니다. 솔버 상태(INFEASIBLE 등)에 따라 구체적 원인을 제공합니다.
- **유연성**: 커스텀 규칙(shifts, shift_hours만 오버라이드), 동적 날짜 계산, 직군별 규칙으로 다양한 시나리오를 지원합니다.
- **한계**: 솔버 시간 제한으로 복잡한 문제에서 실패할 수 있으며, 인터넷 접근이 없어 외부 데이터 의존성을 피합니다.
- **성능 고려**: 단일 워커, 전처리 활성화로 효율성을 높이지만, 대규모 데이터(직원 15명 이상, 4교대)에서 경고를 발행합니다.

이 코드는 근무 관리 시스템의 백엔드로 적합하며, 제약 최적화의 실무적 적용 사례로 활용될 수 있습니다. 추가 개선으로는 솔버 파라미터 튜닝이나 다중 스레딩이 제안됩니다.


예, 주어진 서버 코드에서 클라이언트 요청에 포함된 개인 직원의 "total_monthly_work_hours": 194 값은 스케줄 생성 과정에 적용됩니다. 이를 확인하기 위해 코드의 관련 부분을 분석하겠습니다.

### 적용 과정 설명
1. **요청 처리 흐름**:
   - 클라이언트 요청 JSON이 `handle_request` 함수로 전달됩니다.
   - 이 함수에서 `staff_data`, `shift_type`, `position`, `target_month`, `custom_rules`를 추출합니다.
   - 이후 `create_individual_shift_schedule` 함수를 호출하여 스케줄을 생성합니다.

2. **입력 검증**:
   - `validate_request_parameters` 함수에서 직원 데이터의 필수 항목(포함하여 "total_monthly_work_hours")을 확인합니다.
   - 해당 값이 100~250 범위 내에 있는지 검증하며, 예시의 194는 유효합니다. (오류가 발생하지 않음)

3. **제약 조건 적용**:
   - `apply_position_constraints` 함수에서 각 직원별로 월 근무시간 제약을 설정합니다.
   - 핵심 로직:
     - `base_monthly_hours = person.get("total_monthly_work_hours", rules.get("max_monthly_hours", 190))`
       - 요청에서 제공된 "total_monthly_work_hours" (예: 194)를 우선적으로 사용합니다. 값이 없으면 기본 규칙(간호 직군의 경우 190)으로 대체합니다.
     - 상한: `max_monthly_hours = int(base_monthly_hours * 1.1)` (194의 경우 약 213시간).
     - 하한: `min_monthly_hours = base_monthly_hours - 20` (194의 경우 174시간).
     - 총 월 근무시간 변수(`monthly_hours`)를 계산한 후, CP 모델에 `model.Add(monthly_hours <= max_monthly_hours)`와 `model.Add(monthly_hours >= min_monthly_hours)`를 추가합니다.
   - 따라서 194시간은 각 직원의 월 근무시간 범위(174~213시간)를 결정하는 기준으로 직접 반영됩니다.

4. **스케줄 생성 및 통계**:
   - 솔버가 성공적으로 해를 찾으면, 생성된 스케줄에서 실제 근무시간(`actual_hours`)을 계산합니다.
   - 통계 출력에서 "max_hours"로 194가 사용되며, 여유 시간도 이에 기반합니다.

### 주의사항
- 예시 요청에서 직원이 1명뿐이지만, 코드의 최소 인원 제약(각 시프트에 최소 1명 배정)으로 인해 단일 직원으로는 스케줄 생성이 실패할 수 있습니다(솔버 상태: INFEASIBLE). 그러나 "total_monthly_work_hours" 자체는 여전히 제약 조건으로 적용됩니다.
- 다수 직원(예: 10명 이상)으로 요청 시 정상적으로 작동하며, 각 개인의 값이 독립적으로 반영됩니다.

이 값은 개인화된 근무시간 목표를 반영하는 핵심 파라미터로 설계되었으므로, 요청 시 의도대로 적용됩니다. 추가 질문이 있으시면 알려주십시오.