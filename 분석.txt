정상적인 통신 흐름:
  C++ → Python: [헤더][JSON요청] (0.1ms)
  Python 처리: 스케줄 생성 (3-5초)
  Python → C++: [헤더][JSON응답] (0.1ms)
  C++ 파싱: JSON 해석 (1ms)
  총 시간: ~5초

  오류 상황 흐름:
  C++ → Python: [헤더][JSON요청] (0.1ms)
  Python 처리: 스케줄 생성 완료 (3-5초)
  Python → C++: [잘못된 헤더][JSON응답] (0.1ms)
  C++ 해석: "2GB 데이터를 받아야 함"
  C++ 대기: recv() 블로킹 상태 (30초 타임아웃)
  C++ 포기: "응답 수신 실패" 반환

  🔧 실제 코드에서 발생했을 상황

  Python 서버 측 (수정 전 코드):

  # 잘못된 구현 (Big-endian)
  response_json = json.dumps(schedule_data, ensure_ascii=False)
  response_bytes = response_json.encode('utf-8')

  total_size = len(response_bytes)  # 예: 125
  json_size = len(response_bytes)   # 예: 125

  # Big-endian으로 전송 (문제!)
  header = struct.pack('>I', total_size) + struct.pack('>I', json_size)
  # 결과: [0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 0x7D]

  conn.sendall(header + response_bytes)

  C++ 클라이언트 측 (수신 시도):

  // receivePacket() 함수에서
  char header[8];
  recv(clientSocket, header, 8, 0);

  uint32_t totalSize, jsonSize;
  memcpy(&totalSize, header, 4);      // Little-endian 해석
  memcpy(&jsonSize, header + 4, 4);   // Little-endian 해석

  // 결과: totalSize = 0x7D000000 = 2,097,152,000
  // 결과: jsonSize = 0x7D000000 = 2,097,152,000

  // 유효성 검증에서 실패!
  if (jsonSize > totalSize || totalSize > 10 * 1024 * 1024) {
      std::cerr << "헤더 정보 비정상" << std::endl;
      return false;  // 여기서 실패 반환!
  }

  🎯 결론: 95% 확신하는 원인

  엔디언 불일치가 주범입니다:

  1. Python 서버: Big-endian ('>I') 사용하여 응답 헤더 전송
  2. C++ 클라이언트: Little-endian 해석으로 헤더 읽음
  3. 결과: 125바이트를 2GB로 오해석
  4. C++ 반응: "비정상적 크기" 판단하여 연결 종료
  5. 오류 메시지: "[Python 통신] 응답 수신 실패"

  ⚡ 수정 후 해결 확인

  현재 적용된 수정사항이 이 문제를 해결했습니다:

  # 수정된 구현 (Little-endian)
  header = struct.pack('<I', total_size) + struct.pack('<I', json_size)
  # 결과: [0x7D, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00]

  이제 C++ 클라이언트가 올바르게 125바이트로 해석할 수 있어 통신이 정상화되었습니다! 🎉

