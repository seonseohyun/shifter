# 근무표 생성 시스템 변경점 및 개선사항

## 📅 변경 일자: 2025-08-04

## 🔄 주요 변경사항

### 1. 월 총 근무시간 제약조건 추가
- **변경 내용**: `total_monthly_work_hours` 필드 지원 추가
- **구현 위치**: `server_shift_scheduler.py` 라인 95-103
- **세부사항**:
  - 각 직원별 월 최대 근무시간 설정 가능
  - 10% 여유분 자동 적용으로 해 찾기 가능성 증대
  - 기본값: 180시간 (미설정시)
  - 예시: 180시간 → 198시간(여유분 포함)으로 제약 적용

### 2. 제약조건 완화를 통한 성능 최적화
- **주당 근무시간 제한**: 40시간 → 50시간 (라인 105-112)
- **최소 휴무일**: 월 3일 → 2일 (라인 90-93)
- **야간 근무 후 휴무**: 소프트 제약 → 하드 제약으로 단순화
  - 복잡한 위반 변수 제거로 성능 대폭 향상
  - 목적함수 단순화: 야간 근무 균등성만 고려

### 3. 솔버 성능 최적화
- **시간 제한**: 120초 → 30초
- **워커 수**: 4개 → 1개 (오버헤드 최소화)
- **불필요한 파라미터 제거**: 호환성 문제 해결
- **전처리 유지**: `cp_model_presolve = True` 유지

### 4. 디버깅 및 모니터링 개선
- **월 총 근무시간 통계** 출력 추가 (라인 180-183)
- **솔버 상태 및 해결 시간** 실시간 출력
- **야간 근무 균등성** 지표 출력

## 📊 성능 개선 결과

### Before (기존)
- 20명 직원: 76초+ (타임아웃 위험)
- 해 찾기 실패 빈번
- 메모리 사용량 과다

### After (개선 후)  
- 10명 직원: 0.34초 (매우 빠름)
- 20명 직원: 추정 10-20초 이내
- 안정적인 해 생성
- 메모리 효율성 증대

## 🔧 기술적 개선사항

### 변수 복잡도 감소
- 소프트 제약 위반 변수 제거: `night_violation_vars` 삭제
- 목적함수 단순화: 단일 지표 최적화
- 제약조건 수 대폭 감소

### 알고리즘 최적화
- 하드 제약 사용으로 탐색 공간 명확화
- 단일 워커 사용으로 동기화 오버헤드 제거
- 전처리 유지로 불필요한 변수 사전 제거

## 🎯 향후 확장 전략: JSON 기반 제약사항/요구사항 처리

### 1. 제약사항 JSON 스키마 설계

```json
{
  "schedule_constraints": {
    "global_constraints": {
      "max_weekly_hours": 60,
      "min_monthly_off_days": 2,
      "night_shift_rest_required": true,
      "max_consecutive_work_days": 6
    },
    "shift_constraints": {
      "min_staff_per_shift": {
        "D": 1, "E": 1, "N": 1, "O": 0
      },
      "max_staff_per_shift": {
        "D": 10, "E": 10, "N": 10, "O": 20
      }
    },
    "staff_specific_constraints": [
      {
        "staff_id": 101,
        "max_monthly_hours": 180,
        "preferred_shifts": ["D", "E"],
        "unavailable_dates": ["2025-08-15", "2025-08-16"],
        "max_night_shifts_per_month": 8
      }
    ],
    "business_rules": {
      "senior_staff_night_priority": true,
      "weekend_coverage_required": true,
      "holiday_double_coverage": ["2025-08-15"]
    }
  },
  "optimization_preferences": {
    "priority_order": [
      "staff_satisfaction",
      "workload_balance", 
      "business_continuity"
    ],
    "fairness_weight": 0.7,
    "efficiency_weight": 0.3
  }
}
```

### 2. 구현 전략

#### A. 제약사항 파싱 모듈
```python
def parse_constraints(constraints_json):
    """JSON 제약사항을 OR-Tools 제약으로 변환"""
    global_constraints = constraints_json.get("global_constraints", {})
    staff_constraints = constraints_json.get("staff_specific_constraints", [])
    business_rules = constraints_json.get("business_rules", {})
    
    return {
        "global": process_global_constraints(global_constraints),
        "staff": process_staff_constraints(staff_constraints), 
        "business": process_business_rules(business_rules)
    }
```

#### B. 동적 제약 적용
```python
def apply_dynamic_constraints(model, schedule, constraints):
    """파싱된 제약사항을 모델에 동적 적용"""
    for constraint_type, rules in constraints.items():
        if constraint_type == "global":
            apply_global_constraints(model, schedule, rules)
        elif constraint_type == "staff":
            apply_staff_constraints(model, schedule, rules)
        elif constraint_type == "business":
            apply_business_constraints(model, schedule, rules)
```

#### C. 제약사항 우선순위 처리
```python
def prioritize_constraints(constraints):
    """제약사항을 하드/소프트로 분류하고 우선순위 적용"""
    hard_constraints = []  # 반드시 지켜야 하는 제약
    soft_constraints = []  # 가능하면 지키는 제약 (가중치 적용)
    
    # 우선순위에 따른 분류 로직
    return hard_constraints, soft_constraints
```

### 3. 확장 가능한 아키텍처

#### 제약사항 플러그인 시스템
- **모듈화**: 각 제약사항을 독립적인 모듈로 구현
- **핫스왑**: 운영 중 제약사항 변경 가능
- **버전 관리**: 제약사항 스키마 버전별 호환성 유지

#### 성능 최적화 전략
- **제약사항 캐싱**: 동일한 제약 조합 재사용
- **점진적 최적화**: 하드 제약 먼저, 소프트 제약 순차 적용
- **조기 종료**: 만족 가능한 해 발견시 즉시 반환

### 4. API 확장안

```python
# 새로운 API 엔드포인트
POST /schedule/create
{
  "staff_data": {...},
  "shift_type": 3,
  "constraints": {...},  # 새로운 제약사항 JSON
  "optimization_goals": {...}
}

# 제약사항 검증 엔드포인트  
POST /schedule/validate-constraints
{
  "constraints": {...}
}

# 제약사항 템플릿 제공
GET /schedule/constraint-templates
```

### 5. 구현 우선순위

1. **Phase 1**: 기본 JSON 스키마 정의 및 파싱 모듈
2. **Phase 2**: 핵심 제약사항 동적 적용 (월 근무시간, 휴무일 등)
3. **Phase 3**: 직원별 개별 제약사항 처리
4. **Phase 4**: 비즈니스 룰 및 최적화 목표 적용
5. **Phase 5**: 고급 기능 (제약사항 검증, 템플릿, 성능 최적화)

## 📝 개발자 노트

### 주의사항
- 월 총 근무시간에 10% 여유분이 적용되므로 실제 결과 확인 필요
- 제약조건이 너무 엄격하면 해가 없을 수 있음
- 대용량 데이터(50명 이상)에서는 추가 최적화 필요할 수 있음

### 테스트 케이스
- 10명 직원: 0.34초 (✅ 검증완료)
- 20명 직원: 추가 테스트 필요
- 제약조건 충돌 시나리오 테스트 필요

### 모니터링 지표
- 솔버 해결 시간
- 메모리 사용량  
- 제약조건 위반 횟수
- 월 총 근무시간 준수율