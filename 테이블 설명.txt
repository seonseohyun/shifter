

설명: 조직 내 직원 개별 정보 관리. 팀 단위 조회 시 팀 ID 기준으로 필터 가능.
1. staff - 직원 테이블
필드명	타입	설명	비고
staff_id	varchar	직원 고유 ID (PK)	예: 's101'
name	    varchar	직원 이름	예: 홍길동
position	varchar	직책 또는 직위	예: 간호사
team_id	int	소속 팀 ID (FK)	team.team_id 참조
created_at	timestamp	생성일	자동 기록
updated_at	timestamp	수정일	자동 기록



설명: 팀 또는 근무조 구분 테이블. staff, team_constraint 와 연결됨. 
2. team - 팀 테이블
필드명	         타입	설명	비고
team_id	        int	        팀 고유 ID (PK)	
team_name	    varchar	팀 이름	예: A조, 야간팀



설명: 교대 근무 유형 관리. 스케줄, 제약, 근무기록에 공통으로 참조됨.
3. shift_code - 교대 코드 테이블
필드명	타입	설명	비고
shift_code	char(1)	교대 코드 (PK)	예: D, E, N, O
description	varchar	설명	예: Day, Night


설명: AI 또는 외부 입력으로 생성된 월간 근무표를 JSON으로 저장. 추후 duty_schedule로 파싱하여 활용. 
4. schedule - 생성 스케줄 원본(JSON) 저장 테이블
필드명	타입	설명	비고
schedule_id	int	스케줄 고유 ID (PK)	
staff_id	varchar	대상 직원 ID (FK)	staff.staff_id 참조
schedule_data	text	전체 월간 근무표 (JSON 형식)	예: {"2025-08-01": "D", ...}
created_at	timestamp	생성일	
updated_at	timestamp	수정일	


설명: 실제 근무 내역을 날짜 단위로 저장하는 테이블. 모든 보고서, 통계, 조회의 기반이 됨.

5. duty_schedule - 정규화된 실제 근무 기록 테이블
필드명	타입	설명	비고
id	int	고유 ID (PK)	
staff_id	varchar	근무자 ID (FK)	staff.staff_id 참조
duty_date	date	근무 일자	
shift_code	char(1)	교대코드 (FK)	shift_code.shift_code 참조
work_time	varchar	근무 시간 텍스트 (선택)	예: 09:00~18:00
created_at	timestamp	생성일	
updated_at	timestamp	수정일	


설명: 팀 단위로 적용되는 제약조건 관리. AI 또는 검증 로직에서 활용. 
6. team_constraint - 팀 단위 제약조건 테이블
필드명	타입	설명	비고
id	int	고유 ID (PK)	
team_id	int	팀 ID (FK)	team.team_id 참조
constraint_type	varchar	제약 종류	예: max_night_shift
param_1	varchar	제약 파라미터 값	예: 2
weight_point	int	제약 가중치	AI 알고리즘용
created_at	timestamp	생성일	
updated_at	timestamp	수정일	



설명: 교대 순서에 대한 제약. 예: D 근무 뒤에 바로 N 금지. 스케줄 생성 또는 검증 시 사용.

7. shift_constraint_rule - 교대간 순서 제약 테이블
필드명	타입	설명	비고
id	int	고유 ID (PK)	
shift_code_before	char(1)	이전 교대코드 (FK)	shift_code 참조
shift_code_after	char(1)	다음 교대코드 (FK)	shift_code 참조
constraint_type	varchar	제약 종류	예: forbid_sequence
description	varchar	설명	예: "D 후 N 금지"
weight_point	int	제약 가중치	AI 알고리즘용
created_at	timestamp	생성일	
updated_at	timestamp	수정일	





4번(schedule)과 5번(duty_schedule)의 차이점 — 알고리즘 생성 근무표 기준
구분	schedule 테이블 (4번)	duty_schedule 테이블 (5번)
생성 주체	알고리즘(규칙 기반 근무표 생성)	schedule 테이블의 데이터를 실제 운영 데이터로 정규화한 상태
저장 형태	한 직원(또는 팀)의 전체 근무표를 JSON 문자열로 통째로 저장	날짜·직원·근무조(shift) 단위로 나눠서 행(row)별 저장
용도	생성된 근무표 초안 저장용 / 관리자의 검토용 / 수정용	확정된 근무표를 기반으로 한 출력, 통계, 제약조건 검사, 실제 운용
처리 흐름	알고리즘 → schedule에 저장 → 관리자가 검토/수정 → 확정 → duty_schedule에 분해 저장	duty_schedule 데이터로 실제 근무 스케줄 관리 및 조회
쿼리 용이성	JSON 문자열이라 쿼리·검색 어려움 → 조회 시 파싱 필요	행 단위 정규화 저장 → SQL로 조회·분석 용이


좋은 질문이에요!

3팀에 각 3명씩 (총 9명)인 상황에서 근무표를 **생성 → 저장**하는 큰 흐름과 그에 따라 영향을 받는 테이블들을 정리해볼게요.

---

# 근무표 생성 시 전체 큰 흐름과 영향받는 테이블

### 1. 근무표 생성 (알고리즘)

* 팀별, 인원별 근무조 배치 규칙에 따라 3팀 × 3명 = 9명의 한 달치 근무표를 알고리즘으로 생성
* 보통 **날짜별, 팀별, 직원별 근무조** 정보가 포함됨

### 2. 임시 저장: `schedule` 테이블

* **직원별로 한 달치 근무표를 JSON 형태로 저장**
* 예: 직원 9명 각각에 대해 schedule에 1행씩 insert (총 9건)
* 여기에는 아직 확정되지 않은 초안 데이터가 들어감

### 3. 근무표 검토 및 승인 (관리자)

* 관리자 UI에서 생성된 근무표를 확인/수정/승인
* 수정 시 `schedule`의 JSON 데이터 갱신 가능

### 4. 확정 → 정규화 저장: `duty_schedule` 테이블

* 승인 후 `schedule.schedule_data`에서 JSON을 **파싱해서 날짜·직원·shift 단위로 나눠서 저장**
* 이때 `duty_schedule`에 각 직원의 각 날짜별 근무 정보가 한 줄씩 들어감
* 9명 × 근무일수(예: 30일) = 약 270건 insert

### 5. 제약조건 체크: `team_constraint`, `shift_constraint_rule`

* 근무표 확정 시 또는 운영 중에 제약조건 테이블을 참고해 조건 위반 여부 점검
* 예를 들어 한 팀에 야간 근무는 1명만 허용하는 제약이 있다면 `team_constraint` 테이블에 정의되어 있음
* D 근무 다음에 N 근무 금지 등 교대간 규칙은 `shift_constraint_rule`에서 관리

### 6. 운영 및 조회

* 실제 출근부, 근무 통계, 보고서 등은 `duty_schedule`과 연관 테이블을 기반으로 처리
* 직원별, 팀별, 날짜별 근무 조회 및 집계

---

# 영향을 받거나 쓰이는 주요 테이블 요약

| 테이블명                    | 역할 / 영향 내용                                 |
| ----------------------- | ------------------------------------------ |
| `schedule`              | 근무표 전체 JSON 초안 저장 (직원별 1행, 한 달치 데이터 포함)    |
| `duty_schedule`         | 확정된 근무표를 정규화해 날짜·직원·근무조 단위로 저장 (운영 데이터 핵심) |
| `staff`                 | 직원 기본 정보 (직원ID, 이름, 소속팀 등)                 |
| `team`                  | 팀 정보 (팀명, 팀ID 등)                           |
| `shift_code`            | 근무조 코드와 설명 (D, E, N, O 등)                  |
| `team_constraint`       | 팀 단위 제약조건 (예: 야간 근무 인원 제한)                 |
| `shift_constraint_rule` | 교대간 제약조건 (예: 특정 근무 조합 불허)                  |

---

# 요약

* **근무표 생성** → `schedule`에 임시 JSON 저장
* **승인 후** → JSON 파싱해 `duty_schedule`에 정규화된 데이터로 저장
* 제약조건 테이블들은 **검증/관리용**으로 사용
* 실제 출퇴근 조회 및 통계는 `duty_schedule` 중심으로 진행

---








