개선되어야 할 부분



개선된부분 0802

  ✅ 1. 근무 변경 로그가 반대로 기록되는 문제 해결

  - shift_scheduler.py에서 변경 요청 로그를 "original_shift에서 desired_shift로 변경 요청 적용"으로 명확하게 개선
  - 변경 전후 상태를 정확히 표시하도록 수정

  ✅ 2. 변경 유무 로그가 출력되지 않는 문제 해결

  - 변경 요청 적용 여부를 추적하는 change_applied 플래그 추가
  - 솔버 상태별로 상세한 로그 메시지 추가:
    - [SUCCESS]: 변경 요청이 성공적으로 반영됨
    - [ERROR]: 제약조건 충돌로 해가 없음
    - [INFO]: 변경 요청 없이 기본 근무표 생성
  - 변경 요청 수량 및 적용 여부 로그 추가

  ✅ 3. 변경사항이 없을 때 불필요한 DB 전체 삭제/삽입 최적화

  - Python 스크립트 출력을 캡처하여 실제 변경 여부 판단
  - updateAndExecuteShiftScheduler() 함수가 std::pair<message, scheduleChanged> 반환
  - 스케줄 변경이 확인된 경우에만 generate_and_update_schedule() 실행
  - "해가 없습니다" 등의 경우 DB 업데이트 생략으로 성능 개선

  ✅ 4. 클라이언트에 변경 성공/실패 JSON 응답 구현

  기존 JSON 응답을 세분화하여 개선:
  - "change_success": 변경 요청 성공
  - "no_solution": 제약조건 충돌로 변경 불가능
  - "change_error": 기타 오류 발생

=============================================================================================
branch * Server_dev 이걸로 계속 간다. 나중에 완료전에 개선되어야 할부분은 정리해서 개선 

0802 16:17 
shift_scheduler.py 파일의 변경점 
#staff_data가 팀개념으로 근무표가 생성될것이고







지금 애매한게
#staff_data를 앞으로는 client가 요청시 json을같이 전송하면  
-shift_scheduler.py파일에서 클라이언트로 부터 오는 staff_data를 참조하여 근무표를 생성하도록 변경 하는것인지?
db에 저장된 STAFF 테이블을 참조하여 team_id를 받고 db로부터 근무표를 생성하기위한 정보를 조회하여 근무표를 생성하는 흐름으로 가는것인지?  





매개변수가 (몇교대로 생성할건지: int, team_id:str, 구성원:json_string {} )
{
shift_type : 3,

  // 구성원
  staff_data  = {
      "staff": [
          {"name": "박주영","team_id":"e", "staff_id": 101, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "최정환","team_id":"e", "staff_id": 102, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "문재윤","team_id":"e", "staff_id": 103, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "선서현","team_id":"d", "staff_id": 104, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "박경태","team_id":"d", "staff_id": 105, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "유희라","team_id":"d", "staff_id": 106, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "김유범","team_id":"d", "staff_id": 107, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "박서은","team_id":"b", "staff_id": 108, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "김대업","team_id":"b", "staff_id": 109, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "유예솜","team_id":"b", "staff_id": 110, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "고준영","team_id":"b", "staff_id": 111, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "하진영","team_id":"b", "staff_id": 112, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "오장관","team_id":"a", "staff_id": 113, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "윤진영","team_id":"a", "staff_id": 114, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "한경식","team_id":"a", "staff_id": 115, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "한현희","team_id":"a", "staff_id": 116, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "정종옥","team_id":"c", "staff_id": 117, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "양성규","team_id":"c", "staff_id": 118, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "김화백","team_id":"c", "staff_id": 119, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "이병희","team_id":"c", "staff_id": 120, "grade": 1, "grade_name": "제일높은직급"}
      ]
  }
}

팀 개념 - 병원의 병동 개념 (근무표에 다른 팀이 섞이지 않는 것을 기본전제로 합니다.)
팀 당 하나의 월 근무표가 생깁니다.
근무표가 생성 되면 정규화 되어 각각 테이블에 들어가서
개인별 조회 시 요청 처리하는 방향으로 하겠습니다 !

=============================================================================================

# 팀 개념 도입 및 직원 정보 분리 개발 계획 (2025-08-02)

## 📋 개요
- 현재 근무표 생성 매커니즘은 유지
- 팀별 제약조건 적용을 위한 team_id 개념 도입  
- Python 하드코딩 직원 정보를 DB 또는 클라이언트 JSON으로 분리

## 🗂️ 관련 테이블
```sql
CREATE TABLE `team_constraint` (
  `id` integer PRIMARY KEY,
  `team_id` integer,
  `constraint_type` varchar(255),
  `param_1` varchar(255),
  `weight_point` integer,
  `created_at` timestamp,
  `updated_at` timestamp,
  `team_id` varchar(255)
);
```

## 🚀 Phase 1: Python 스케줄러 개선
### 목표
- `shift_scheduler.py`에서 하드코딩된 `staff_data` 제거
- 동적 직원 정보 로딩 구조 구현

### 작업 내용
1. **함수 시그니처 변경**
   ```python
   def create_individual_shift_schedule(staff_data, shift_type, team_id=None):
   ```

2. **직원 정보 로딩 함수 추가**
   ```python
   def load_staff_data(team_id=None, source='db'):
       if source == 'db':
           return query_staff_from_db(team_id)
       elif source == 'json':
           return load_staff_from_json()
   ```

3. **하드코딩 제거**
   - 현재 189-212줄 `staff_data` 딕셔너리 제거
   - 동적 로딩으로 대체

## 🚀 Phase 2: 팀 제약조건 적용
### 목표
- `team_constraint` 테이블 조회 및 제약조건 동적 적용

### 작업 내용
1. **팀 제약조건 조회 함수**
   ```python
   def load_team_constraints(team_id):
       # team_constraint 테이블에서 team_id별 제약조건 조회
       # constraint_type별 제약조건 파싱 및 적용
   ```

2. **제약조건 적용 로직**
   - 기존 하드코딩된 제약조건과 팀별 제약조건 병합
   - `weight_point`를 활용한 우선순위 적용

## 🚀 Phase 3: C++ 서버 수정
### 목표
- 팀 관련 프로토콜 지원 및 Python 호출 시 팀 정보 전달

### 작업 내용
1. **ChangeShift 프로토콜 확장**
   ```cpp
   else if (j.contains("Protocol") && j["Protocol"] == "ChangeShift") {
       std::string team_id = j.get("team_id", "1"); // 기본값
       // Python 실행 시 team_id 전달
   }
   ```

2. **새로운 프로토콜 추가 검토**
   - `GetTeamInfo`: 팀 정보 조회
   - `SetTeamStaff`: 팀 직원 정보 설정

## 📅 일정 및 우선순위
- **월요일 토의 후** 구체적 개발 방향 확정
- **우선순위**: Phase 1 → Phase 3 → Phase 2
- **변경 가능성**: 요구사항에 따라 계획 수정 예정

## 🔄 현재 보류 사항
- DB 스키마 변경 범위  
- 클라이언트 JSON 구조 정의
- 팀별 제약조건 타입 정의
- 성능 최적화 방안 (DB 커넥션 풀링 등)

## 🎯 결정 필요 사항
1. **직원 정보 전달 방식**
   - 옵션 A: 클라이언트가 JSON으로 staff_data 전송
   - 옵션 B: DB STAFF 테이블에서 team_id로 조회
   
2. **근무표 저장 방식**
   - 현재: JSON 파일 → DB 전체 삭제/삽입
   - 개선: 정규화된 테이블 구조로 직접 저장


   
  - 분석 보고서: 현재 시스템 문제점 4가지 해결방안
  - 개발 계획: /변경이 필요한부분.txt에 단계별 로드맵
  - DB 설계 문서: /database/ 디렉토리 3종 세트
    - 테이블 구조도 (성능 최적화 중심)
    - ERD 다이어그램 (관계 및 인덱스 전략)
    - 상세 명세서 (비즈니스 규칙 포함)

  🚀 핵심 결정사항 (월요일 토의용)

  1. 직원 정보 소스: DB 조회 vs 클라이언트 JSON
  2. 마이그레이션 속도: 점진적 vs 일괄 변경
  3. team_constraint 적용 범위: 어떤 제약조건들을 우선 구현할지

  ⚡ Quick Win 옵션

  - duty_schedule에 team_id 컬럼만 추가해도 즉시 20배 성능 향상 가능

