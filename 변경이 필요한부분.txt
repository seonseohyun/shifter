개선되어야 할 부분

1. 반대로 기록되는걸까? 
 print(f"[INFO] {sid}의 {req['date']} 근무를 {s}로 고정") 
 변경요청이 반대로 들어가는거같은데 D를 O로 변경해야하는데 
 D로 고정 이렇게 로그가 나오고 실제 근무도 변경되지 않는다. - 확인해봐야함 반대로 기록되는 경우를 본거같다.

2. 변경 유무의 로그가 한번도 출력되지 않는 문제




성능/안정성: 트랜잭션 사용은 좋으나, 매 요청마다 Python 실행과 DB 전체 삭제/삽입은 비효율적(대규모 데이터 시 느림). 다중 클라이언트 시 race condition 가능성.

3. 변경이되지 않았을땐 테이블 전체삭제/ insert 동작이 불필요함 
-db 전체 삭제 삽입을 하지 않고 만약 해를 찾을수 없습니다 이련 경우에는 db 내용을 삭제 insert 하는건 불필요한 작업이다. 


현재는  아래의 코드가 무조건 실행되는데  변경요청이 반영되지 않았을 경우에는 DB 갱신이 불필요하다.
// 성공 후 DB 갱신
 generate_and_update_schedule(conn);


-클라이언트에서 근무변경 요청 이후 클라이언트와 연결이 그냥 끊어지는데 끊어지기전에 서버로부터 잘 변경되었는지 아니면 변경실패인지 json으로 응답받아야한다.



개선된부분 0802

  ✅ 1. 근무 변경 로그가 반대로 기록되는 문제 해결

  - shift_scheduler.py에서 변경 요청 로그를 "original_shift에서 desired_shift로 변경 요청 적용"으로 명확하게 개선
  - 변경 전후 상태를 정확히 표시하도록 수정

  ✅ 2. 변경 유무 로그가 출력되지 않는 문제 해결

  - 변경 요청 적용 여부를 추적하는 change_applied 플래그 추가
  - 솔버 상태별로 상세한 로그 메시지 추가:
    - [SUCCESS]: 변경 요청이 성공적으로 반영됨
    - [ERROR]: 제약조건 충돌로 해가 없음
    - [INFO]: 변경 요청 없이 기본 근무표 생성
  - 변경 요청 수량 및 적용 여부 로그 추가

  ✅ 3. 변경사항이 없을 때 불필요한 DB 전체 삭제/삽입 최적화

  - Python 스크립트 출력을 캡처하여 실제 변경 여부 판단
  - updateAndExecuteShiftScheduler() 함수가 std::pair<message, scheduleChanged> 반환
  - 스케줄 변경이 확인된 경우에만 generate_and_update_schedule() 실행
  - "해가 없습니다" 등의 경우 DB 업데이트 생략으로 성능 개선

  ✅ 4. 클라이언트에 변경 성공/실패 JSON 응답 구현

  기존 JSON 응답을 세분화하여 개선:
  - "change_success": 변경 요청 성공
  - "no_solution": 제약조건 충돌로 변경 불가능
  - "change_error": 기타 오류 발생

=============================================================================================
branch * Server_dev 이걸로 계속 간다. 나중에 완료전에 개선되어야 할부분은 정리해서 개선 

0802 16:17 
shift_scheduler.py 파일의 변경점 
#staff_data가 팀개념으로 근무표가 생성될것이고
#staff_data를 앞으로는 client가 json안에 넣어 요청을해서 python에서 staff_data를 참조하여 근무표를 생성하도록 변경



매개변수가 (몇교대로 생성할건지: int, team_id:str, 구성원:json_string {} )
{
shift_type : 3,

team_id : "A_team",
  // 구성원
  staff_data  = {
      "staff": [
          {"name": "박주영","team_id":"e", "staff_id": 101, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "최정환","team_id":"e", "staff_id": 102, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "문재윤","team_id":"e", "staff_id": 103, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "선서현","team_id":"d", "staff_id": 104, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "박경태","team_id":"d", "staff_id": 105, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "유희라","team_id":"d", "staff_id": 106, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "김유범","team_id":"d", "staff_id": 107, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "박서은","team_id":"b", "staff_id": 108, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "김대업","team_id":"b", "staff_id": 109, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "유예솜","team_id":"b", "staff_id": 110, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "고준영","team_id":"b", "staff_id": 111, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "하진영","team_id":"b", "staff_id": 112, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "오장관","team_id":"a", "staff_id": 113, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "윤진영","team_id":"a", "staff_id": 114, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "한경식","team_id":"a", "staff_id": 115, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "한현희","team_id":"a", "staff_id": 116, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "정종옥","team_id":"c", "staff_id": 117, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "양성규","team_id":"c", "staff_id": 118, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "김화백","team_id":"c", "staff_id": 119, "grade": 1, "grade_name": "제일높은직급"},
          {"name": "이병희","team_id":"c", "staff_id": 120, "grade": 1, "grade_name": "제일높은직급"}
      ]
  }
}

팀 개념 - 병원의 병동 개념 (근무표에 다른 팀이 섞이지 않는 것을 기본전제로 합니다.)
팀 당 하나의 월 근무표가 생깁니다.
근무표가 생성 되면 정규화 되어 각각 테이블에 들어가서
개인별 조회 시 요청 처리하는 방향으로 하겠습니다 !